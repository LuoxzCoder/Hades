-- Generated by lua-capnproto 0.1.3-1 on Fri Aug 12 16:14:46 2016
-- https://github.com/cloudflare/lua-capnproto.git


local ffi = require "ffi"
local capnp = require "capnp"
local bit = require "bit"

local ceil              = math.ceil
local write_struct_field= capnp.write_struct_field
local read_struct_field = capnp.read_struct_field
local read_text         = capnp.read_text
local write_text        = capnp.write_text
local get_enum_val      = capnp.get_enum_val
local get_enum_name     = capnp.get_enum_name
local get_data_off      = capnp.get_data_off
local write_listp_buf   = capnp.write_listp_buf
local write_structp_buf = capnp.write_structp_buf
local write_structp     = capnp.write_structp
local read_struct_buf   = capnp.read_struct_buf
local read_listp_struct = capnp.read_listp_struct
local read_list_data    = capnp.read_list_data
local write_list        = capnp.write_list
local write_list_data   = capnp.write_list_data
local ffi_new           = ffi.new
local ffi_string        = ffi.string
local ffi_cast          = ffi.cast
local ffi_copy          = ffi.copy
local ffi_fill          = ffi.fill
local ffi_typeof        = ffi.typeof
local band, bor, bxor = bit.band, bit.bor, bit.bxor

local pint8    = ffi_typeof("int8_t *")
local pint16   = ffi_typeof("int16_t *")
local pint32   = ffi_typeof("int32_t *")
local pint64   = ffi_typeof("int64_t *")
local puint8   = ffi_typeof("uint8_t *")
local puint16  = ffi_typeof("uint16_t *")
local puint32  = ffi_typeof("uint32_t *")
local puint64  = ffi_typeof("uint64_t *")
local pbool    = ffi_typeof("uint8_t *")
local pfloat32 = ffi_typeof("float *")
local pfloat64 = ffi_typeof("double *")


local ok, new_tab = pcall(require, "table.new")

if not ok then
    new_tab = function (narr, nrec) return {} end
end

local round8 = function(size)
    return ceil(size / 8) * 8
end

local str_buf
local default_segment_size = 4096

local function get_str_buf(size)
    if size > default_segment_size then
        return ffi_new("char[?]", size)
    end

    if not str_buf then
        str_buf = ffi_new("char[?]", default_segment_size)
    end
    return str_buf
end

-- Estimated from #nodes, not accurate
local _M = new_tab(0, 38)


_M.MsgLogoutRequest = {
    id = "9610339391854294790",
    displayName = "msg_capn.capnp:MsgLogoutRequest",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "queueid", default = 0, ["type"] = "uint32" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgLogoutRequest.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["queueid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 2, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgLogoutRequest.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgLogoutRequest, 0)

        -- skip header & struct pointer
        _M.MsgLogoutRequest.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["queueid"] = read_struct_field(p32, "uint32", 32, 2, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgLogoutRequest.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgLoginRequest = {
    id = "15448589412952234362",
    displayName = "msg_capn.capnp:MsgLoginRequest",
    dataWordCount = 1,
    pointerCount = 2,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "username", default = "", ["type"] = "text" },
        { name = "password", default = "", ["type"] = "text" },
        { name = "devicetype", default = 0, ["type"] = "int8" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        -- text
        value = data["username"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        -- text
        value = data["password"]
        if type(value) == "string" then
            -- size 1, including trailing NULL
            size = size + round8(#value + 1)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgLoginRequest.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["username"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.MsgLoginRequest, 0, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.MsgLoginRequest, 0, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["password"]
        if type(value) == "string" then
            local data_off = get_data_off(_M.MsgLoginRequest, 1, pos)

            local len = #value + 1
            write_listp_buf(p32, _M.MsgLoginRequest, 1, 2, len, data_off)

            ffi_copy(p32 + pos / 4, value)
            pos = pos + round8(len)
        end

        value = data["devicetype"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int8", 8, 0, 0)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgLoginRequest.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgLoginRequest, 0)

        -- skip header & struct pointer
        _M.MsgLoginRequest.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.MsgLoginRequest, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 0 + 1 + off) * 2)
            s["username"] = ffi_string(p8, num - 1)
        else
            s["username"] = nil
        end

        -- text
        local off, size, num = read_listp_struct(p32, header, _M.MsgLoginRequest, 1)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            local p8 = ffi_cast(pint8, p32 + (1 + 1 + 1 + off) * 2)
            s["password"] = ffi_string(p8, num - 1)
        else
            s["password"] = nil
        end

        s["devicetype"] = read_struct_field(p32, "int8", 8, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgLoginRequest.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgLeaveScene = {
    id = "12082147434755686606",
    displayName = "msg_capn.capnp:MsgLeaveScene",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgLeaveScene.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgLeaveScene.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgLeaveScene, 0)

        -- skip header & struct pointer
        _M.MsgLeaveScene.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgLeaveScene.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgEntrySceneRequest = {
    id = "15011765645573318650",
    displayName = "msg_capn.capnp:MsgEntrySceneRequest",
    dataWordCount = 2,
    pointerCount = 1,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 5,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "sceneid", default = 0, ["type"] = "uint32" },
        { name = "camp", default = 0, ["type"] = "int8" },
        { name = "weaponids", default = "opaque pointer", ["type"] = "list" },
        { name = "curweaponid", default = 0, ["type"] = "uint16" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        -- list
        if data["weaponids"] and type(data["weaponids"]) == "table" then
            -- num * acutal size
            size = size + round8(#data["weaponids"] * 2)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgEntrySceneRequest.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["sceneid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 2, 0)
        end

        value = data["camp"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int8", 8, 12, 0)
        end

        value = data["weaponids"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgEntrySceneRequest, 0, pos)
            pos = pos + write_list(p32 + _M.MsgEntrySceneRequest.dataWordCount * 2 + 0 * 2,
                    value, (data_off + 1) * 8, "list", "uint16")
        end

        value = data["curweaponid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 7, 0)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgEntrySceneRequest.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgEntrySceneRequest, 0)

        -- skip header & struct pointer
        _M.MsgEntrySceneRequest.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["sceneid"] = read_struct_field(p32, "uint32", 32, 2, 0)

        s["camp"] = read_struct_field(p32, "int8", 8, 12, 0)

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.MsgEntrySceneRequest, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["weaponids"] = read_list_data(p32 + (2 + 0 + 1 + off) * 2, header,
                    num, "uint16")
        else
            s["weaponids"] = nil
        end

        s["curweaponid"] = read_struct_field(p32, "uint16", 16, 7, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgEntrySceneRequest.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerViveDeviceInfo = {
    id = "10087840673626221518",
    displayName = "msg_capn.capnp:MsgPlayerViveDeviceInfo",
    dataWordCount = 0,
    pointerCount = 6,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 6,

    fields = {
        { name = "lefthandpos", default = "opaque pointer", ["type"] = "struct" },
        { name = "lefthandrotation", default = "opaque pointer", ["type"] = "struct" },
        { name = "righthandpos", default = "opaque pointer", ["type"] = "struct" },
        { name = "righthandrotation", default = "opaque pointer", ["type"] = "struct" },
        { name = "headpos", default = "opaque pointer", ["type"] = "struct" },
        { name = "headrotation", default = "opaque pointer", ["type"] = "struct" },
    },

    calc_size_struct = function(data)
        local size = 48
        local value
        -- struct
        value = data["lefthandpos"]
        if type(value) == "table" then
            size = size + _M.MsgPosition.calc_size_struct(value)
        end
        -- struct
        value = data["lefthandrotation"]
        if type(value) == "table" then
            size = size + _M.MsgRotation.calc_size_struct(value)
        end
        -- struct
        value = data["righthandpos"]
        if type(value) == "table" then
            size = size + _M.MsgPosition.calc_size_struct(value)
        end
        -- struct
        value = data["righthandrotation"]
        if type(value) == "table" then
            size = size + _M.MsgRotation.calc_size_struct(value)
        end
        -- struct
        value = data["headpos"]
        if type(value) == "table" then
            size = size + _M.MsgPosition.calc_size_struct(value)
        end
        -- struct
        value = data["headrotation"]
        if type(value) == "table" then
            size = size + _M.MsgRotation.calc_size_struct(value)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerViveDeviceInfo.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 48 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["lefthandpos"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfo, 0, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfo, _M.MsgPosition, 0, data_off)
            local size = _M.MsgPosition.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["lefthandrotation"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfo, 1, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfo, _M.MsgRotation, 1, data_off)
            local size = _M.MsgRotation.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["righthandpos"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfo, 2, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfo, _M.MsgPosition, 2, data_off)
            local size = _M.MsgPosition.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["righthandrotation"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfo, 3, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfo, _M.MsgRotation, 3, data_off)
            local size = _M.MsgRotation.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["headpos"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfo, 4, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfo, _M.MsgPosition, 4, data_off)
            local size = _M.MsgPosition.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["headrotation"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfo, 5, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfo, _M.MsgRotation, 5, data_off)
            local size = _M.MsgRotation.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end
        return pos - start + 48
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerViveDeviceInfo.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerViveDeviceInfo, 0)

        -- skip header & struct pointer
        _M.MsgPlayerViveDeviceInfo.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        -- struct
        local p = p32 + (0 + 0) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["lefthandpos"] then
                s["lefthandpos"] = new_tab(0, 2)
            end
            _M.MsgPosition.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["lefthandpos"])
        else
            s["lefthandpos"] = nil
        end

        -- struct
        local p = p32 + (0 + 1) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["lefthandrotation"] then
                s["lefthandrotation"] = new_tab(0, 2)
            end
            _M.MsgRotation.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["lefthandrotation"])
        else
            s["lefthandrotation"] = nil
        end

        -- struct
        local p = p32 + (0 + 2) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["righthandpos"] then
                s["righthandpos"] = new_tab(0, 2)
            end
            _M.MsgPosition.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["righthandpos"])
        else
            s["righthandpos"] = nil
        end

        -- struct
        local p = p32 + (0 + 3) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["righthandrotation"] then
                s["righthandrotation"] = new_tab(0, 2)
            end
            _M.MsgRotation.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["righthandrotation"])
        else
            s["righthandrotation"] = nil
        end

        -- struct
        local p = p32 + (0 + 4) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["headpos"] then
                s["headpos"] = new_tab(0, 2)
            end
            _M.MsgPosition.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["headpos"])
        else
            s["headpos"] = nil
        end

        -- struct
        local p = p32 + (0 + 5) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["headrotation"] then
                s["headrotation"] = new_tab(0, 2)
            end
            _M.MsgRotation.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["headrotation"])
        else
            s["headrotation"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerViveDeviceInfo.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerFire = {
    id = "15445951373871441827",
    displayName = "msg_capn.capnp:MsgPlayerFire",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 4,

    fields = {
        { name = "weapontype", default = 0, ["type"] = "int8" },
        { name = "islefthand", default = 0, ["type"] = "bool" },
        { name = "hitplayerid", default = 0, ["type"] = "uint64" },
        { name = "damage", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerFire.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["weapontype"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int8", 8, 0, 0)
        end

        value = data["islefthand"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 8, 0)
        end

        value = data["hitplayerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 1, 0)
        end

        value = data["damage"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 1, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerFire.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerFire, 0)

        -- skip header & struct pointer
        _M.MsgPlayerFire.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["weapontype"] = read_struct_field(p32, "int8", 8, 0, 0)

        s["islefthand"] = read_struct_field(p32, "bool", 1, 8, 0)

        s["hitplayerid"] = read_struct_field(p32, "uint64", 64, 1, 0)

        s["damage"] = read_struct_field(p32, "float32", 32, 1, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerFire.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerReload = {
    id = "17907170327881629920",
    displayName = "msg_capn.capnp:MsgPlayerReload",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "islefthand", default = 0, ["type"] = "bool" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerReload.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["islefthand"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerReload.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerReload, 0)

        -- skip header & struct pointer
        _M.MsgPlayerReload.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["islefthand"] = read_struct_field(p32, "bool", 1, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerReload.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerChangeWeapon = {
    id = "17576849806046056070",
    displayName = "msg_capn.capnp:MsgPlayerChangeWeapon",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "weaponid", default = 0, ["type"] = "uint16" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerChangeWeapon.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["weaponid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerChangeWeapon.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerChangeWeapon, 0)

        -- skip header & struct pointer
        _M.MsgPlayerChangeWeapon.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["weaponid"] = read_struct_field(p32, "uint16", 16, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerChangeWeapon.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerMoveStop = {
    id = "14491519200524681810",
    displayName = "msg_capn.capnp:MsgPlayerMoveStop",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "posx", default = 0, ["type"] = "float32" },
        { name = "posy", default = 0, ["type"] = "float32" },
        { name = "posz", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerMoveStop.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["posx"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 0, 0)
        end

        value = data["posy"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 1, 0)
        end

        value = data["posz"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 2, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerMoveStop.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerMoveStop, 0)

        -- skip header & struct pointer
        _M.MsgPlayerMoveStop.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["posx"] = read_struct_field(p32, "float32", 32, 0, 0)

        s["posy"] = read_struct_field(p32, "float32", 32, 1, 0)

        s["posz"] = read_struct_field(p32, "float32", 32, 2, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerMoveStop.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerMoveStart = {
    id = "10349697139240651136",
    displayName = "msg_capn.capnp:MsgPlayerMoveStart",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 4,

    fields = {
        { name = "dir", default = 0, ["type"] = "float32" },
        { name = "posx", default = 0, ["type"] = "float32" },
        { name = "posy", default = 0, ["type"] = "float32" },
        { name = "posz", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerMoveStart.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["dir"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 0, 0)
        end

        value = data["posx"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 1, 0)
        end

        value = data["posy"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 2, 0)
        end

        value = data["posz"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 3, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerMoveStart.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerMoveStart, 0)

        -- skip header & struct pointer
        _M.MsgPlayerMoveStart.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["dir"] = read_struct_field(p32, "float32", 32, 0, 0)

        s["posx"] = read_struct_field(p32, "float32", 32, 1, 0)

        s["posy"] = read_struct_field(p32, "float32", 32, 2, 0)

        s["posz"] = read_struct_field(p32, "float32", 32, 3, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerMoveStart.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerMoveMeetObstacle = {
    id = "14482322570059680889",
    displayName = "msg_capn.capnp:MsgPlayerMoveMeetObstacle",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "posx", default = 0, ["type"] = "float32" },
        { name = "posy", default = 0, ["type"] = "float32" },
        { name = "posz", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerMoveMeetObstacle.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["posx"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 0, 0)
        end

        value = data["posy"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 1, 0)
        end

        value = data["posz"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 2, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerMoveMeetObstacle.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerMoveMeetObstacle, 0)

        -- skip header & struct pointer
        _M.MsgPlayerMoveMeetObstacle.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["posx"] = read_struct_field(p32, "float32", 32, 0, 0)

        s["posy"] = read_struct_field(p32, "float32", 32, 1, 0)

        s["posz"] = read_struct_field(p32, "float32", 32, 2, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerMoveMeetObstacle.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerFace = {
    id = "12517064244429473323",
    displayName = "msg_capn.capnp:MsgPlayerFace",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "yaw", default = 0, ["type"] = "float32" },
        { name = "pitch", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerFace.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["yaw"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 0, 0)
        end

        value = data["pitch"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 1, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerFace.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerFace, 0)

        -- skip header & struct pointer
        _M.MsgPlayerFace.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["yaw"] = read_struct_field(p32, "float32", 32, 0, 0)

        s["pitch"] = read_struct_field(p32, "float32", 32, 1, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerFace.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerRevive = {
    id = "18150324095829576634",
    displayName = "msg_capn.capnp:MsgPlayerRevive",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "health", default = 0, ["type"] = "uint64" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerRevive.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["health"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerRevive.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerRevive, 0)

        -- skip header & struct pointer
        _M.MsgPlayerRevive.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["health"] = read_struct_field(p32, "uint64", 64, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerRevive.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerProjectileDamage = {
    id = "15937659513977878345",
    displayName = "msg_capn.capnp:MsgPlayerProjectileDamage",
    dataWordCount = 1,
    pointerCount = 1,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "weapontype", default = 0, ["type"] = "int8" },
        { name = "damageplayers", default = "opaque pointer", ["type"] = "list" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        -- list
        if data["damageplayers"] and type(data["damageplayers"]) == "table" then
            size = size + 8
            local num2 = #data["damageplayers"]
            for i2=1, num2 do
                size = size + _M.MsgDamagePlayer.calc_size_struct(data["damageplayers"][i2])
            end
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerProjectileDamage.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["weapontype"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int8", 8, 0, 0)
        end

        value = data["damageplayers"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerProjectileDamage, 0, pos)
            pos = pos + write_list(p32 + _M.MsgPlayerProjectileDamage.dataWordCount * 2 + 0 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.MsgDamagePlayer)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerProjectileDamage.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerProjectileDamage, 0)

        -- skip header & struct pointer
        _M.MsgPlayerProjectileDamage.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["weapontype"] = read_struct_field(p32, "int8", 8, 0, 0)

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.MsgPlayerProjectileDamage, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["damageplayers"] = read_list_data(p32 + (1 + 0 + 1 + off) * 2, header,
                    num, "struct", _M.MsgDamagePlayer)
        else
            s["damageplayers"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerProjectileDamage.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgLogoutResult = {
    id = "17834923797070014731",
    displayName = "msg_capn.capnp:MsgLogoutResult",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "success", default = 0, ["type"] = "bool" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgLogoutResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["success"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgLogoutResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgLogoutResult, 0)

        -- skip header & struct pointer
        _M.MsgLogoutResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["success"] = read_struct_field(p32, "bool", 1, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgLogoutResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgLoginResult = {
    id = "17789619452653610693",
    displayName = "msg_capn.capnp:MsgLoginResult",
    dataWordCount = 3,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 4,

    fields = {
        { name = "success", default = 0, ["type"] = "bool" },
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "queueid", default = 0, ["type"] = "uint32" },
        { name = "time", default = 0, ["type"] = "float64" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgLoginResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["success"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 0, 0)
        end

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 1, 0)
        end

        value = data["queueid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 1, 0)
        end

        value = data["time"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float64", 64, 2, 0)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgLoginResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgLoginResult, 0)

        -- skip header & struct pointer
        _M.MsgLoginResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["success"] = read_struct_field(p32, "bool", 1, 0, 0)

        s["playerid"] = read_struct_field(p32, "uint64", 64, 1, 0)

        s["queueid"] = read_struct_field(p32, "uint32", 32, 1, 0)

        s["time"] = read_struct_field(p32, "float64", 64, 2, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgLoginResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgBroadcastPlayerLeave = {
    id = "16656384132730791915",
    displayName = "msg_capn.capnp:MsgBroadcastPlayerLeave",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgBroadcastPlayerLeave.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgBroadcastPlayerLeave.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgBroadcastPlayerLeave, 0)

        -- skip header & struct pointer
        _M.MsgBroadcastPlayerLeave.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgBroadcastPlayerLeave.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgBroadcastPlayerInfo = {
    id = "9666538693760135705",
    displayName = "msg_capn.capnp:MsgBroadcastPlayerInfo",
    dataWordCount = 4,
    pointerCount = 1,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 9,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "dir", default = 0, ["type"] = "float32" },
        { name = "posx", default = 0, ["type"] = "float32" },
        { name = "posy", default = 0, ["type"] = "float32" },
        { name = "posz", default = 0, ["type"] = "float32" },
        { name = "devicetype", default = 0, ["type"] = "int8" },
        { name = "camp", default = 0, ["type"] = "int8" },
        { name = "weaponids", default = "opaque pointer", ["type"] = "list" },
        { name = "curweaponid", default = 0, ["type"] = "uint16" },
    },

    calc_size_struct = function(data)
        local size = 40
        local value
        -- list
        if data["weaponids"] and type(data["weaponids"]) == "table" then
            -- num * acutal size
            size = size + round8(#data["weaponids"] * 2)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgBroadcastPlayerInfo.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 40 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["dir"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 2, 0)
        end

        value = data["posx"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 3, 0)
        end

        value = data["posy"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 4, 0)
        end

        value = data["posz"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 5, 0)
        end

        value = data["devicetype"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int8", 8, 24, 0)
        end

        value = data["camp"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int8", 8, 25, 0)
        end

        value = data["weaponids"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgBroadcastPlayerInfo, 0, pos)
            pos = pos + write_list(p32 + _M.MsgBroadcastPlayerInfo.dataWordCount * 2 + 0 * 2,
                    value, (data_off + 1) * 8, "list", "uint16")
        end

        value = data["curweaponid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 13, 0)
        end
        return pos - start + 40
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgBroadcastPlayerInfo.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgBroadcastPlayerInfo, 0)

        -- skip header & struct pointer
        _M.MsgBroadcastPlayerInfo.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["dir"] = read_struct_field(p32, "float32", 32, 2, 0)

        s["posx"] = read_struct_field(p32, "float32", 32, 3, 0)

        s["posy"] = read_struct_field(p32, "float32", 32, 4, 0)

        s["posz"] = read_struct_field(p32, "float32", 32, 5, 0)

        s["devicetype"] = read_struct_field(p32, "int8", 8, 24, 0)

        s["camp"] = read_struct_field(p32, "int8", 8, 25, 0)

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.MsgBroadcastPlayerInfo, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["weaponids"] = read_list_data(p32 + (4 + 0 + 1 + off) * 2, header,
                    num, "uint16")
        else
            s["weaponids"] = nil
        end

        s["curweaponid"] = read_struct_field(p32, "uint16", 16, 13, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgBroadcastPlayerInfo.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerViveDeviceInfoResult = {
    id = "12827450440673971836",
    displayName = "msg_capn.capnp:MsgPlayerViveDeviceInfoResult",
    dataWordCount = 1,
    pointerCount = 6,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 7,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "lefthandpos", default = "opaque pointer", ["type"] = "struct" },
        { name = "lefthandrotation", default = "opaque pointer", ["type"] = "struct" },
        { name = "righthandpos", default = "opaque pointer", ["type"] = "struct" },
        { name = "righthandrotation", default = "opaque pointer", ["type"] = "struct" },
        { name = "headpos", default = "opaque pointer", ["type"] = "struct" },
        { name = "headrotation", default = "opaque pointer", ["type"] = "struct" },
    },

    calc_size_struct = function(data)
        local size = 56
        local value
        -- struct
        value = data["lefthandpos"]
        if type(value) == "table" then
            size = size + _M.MsgPosition.calc_size_struct(value)
        end
        -- struct
        value = data["lefthandrotation"]
        if type(value) == "table" then
            size = size + _M.MsgRotation.calc_size_struct(value)
        end
        -- struct
        value = data["righthandpos"]
        if type(value) == "table" then
            size = size + _M.MsgPosition.calc_size_struct(value)
        end
        -- struct
        value = data["righthandrotation"]
        if type(value) == "table" then
            size = size + _M.MsgRotation.calc_size_struct(value)
        end
        -- struct
        value = data["headpos"]
        if type(value) == "table" then
            size = size + _M.MsgPosition.calc_size_struct(value)
        end
        -- struct
        value = data["headrotation"]
        if type(value) == "table" then
            size = size + _M.MsgRotation.calc_size_struct(value)
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerViveDeviceInfoResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 56 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["lefthandpos"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfoResult, 0, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfoResult, _M.MsgPosition, 0, data_off)
            local size = _M.MsgPosition.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["lefthandrotation"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfoResult, 1, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfoResult, _M.MsgRotation, 1, data_off)
            local size = _M.MsgRotation.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["righthandpos"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfoResult, 2, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfoResult, _M.MsgPosition, 2, data_off)
            local size = _M.MsgPosition.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["righthandrotation"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfoResult, 3, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfoResult, _M.MsgRotation, 3, data_off)
            local size = _M.MsgRotation.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["headpos"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfoResult, 4, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfoResult, _M.MsgPosition, 4, data_off)
            local size = _M.MsgPosition.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end

        value = data["headrotation"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerViveDeviceInfoResult, 5, pos)
            write_structp_buf(p32, _M.MsgPlayerViveDeviceInfoResult, _M.MsgRotation, 5, data_off)
            local size = _M.MsgRotation.flat_serialize(value, p32 + pos / 4)
            pos = pos + size
        end
        return pos - start + 56
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerViveDeviceInfoResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerViveDeviceInfoResult, 0)

        -- skip header & struct pointer
        _M.MsgPlayerViveDeviceInfoResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        -- struct
        local p = p32 + (1 + 0) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["lefthandpos"] then
                s["lefthandpos"] = new_tab(0, 2)
            end
            _M.MsgPosition.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["lefthandpos"])
        else
            s["lefthandpos"] = nil
        end

        -- struct
        local p = p32 + (1 + 1) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["lefthandrotation"] then
                s["lefthandrotation"] = new_tab(0, 2)
            end
            _M.MsgRotation.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["lefthandrotation"])
        else
            s["lefthandrotation"] = nil
        end

        -- struct
        local p = p32 + (1 + 2) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["righthandpos"] then
                s["righthandpos"] = new_tab(0, 2)
            end
            _M.MsgPosition.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["righthandpos"])
        else
            s["righthandpos"] = nil
        end

        -- struct
        local p = p32 + (1 + 3) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["righthandrotation"] then
                s["righthandrotation"] = new_tab(0, 2)
            end
            _M.MsgRotation.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["righthandrotation"])
        else
            s["righthandrotation"] = nil
        end

        -- struct
        local p = p32 + (1 + 4) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["headpos"] then
                s["headpos"] = new_tab(0, 2)
            end
            _M.MsgPosition.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["headpos"])
        else
            s["headpos"] = nil
        end

        -- struct
        local p = p32 + (1 + 5) * 2 -- p32, dataWordCount, offset
        local off, dw, pw = read_struct_buf(p, header)
        if off and dw and pw then
            if not s["headrotation"] then
                s["headrotation"] = new_tab(0, 2)
            end
            _M.MsgRotation.parse_struct_data(p + 2 + off * 2, dw, pw, header, s["headrotation"])
        else
            s["headrotation"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerViveDeviceInfoResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerFireResult = {
    id = "13053003535344214042",
    displayName = "msg_capn.capnp:MsgPlayerFireResult",
    dataWordCount = 3,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 5,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "weapontype", default = 0, ["type"] = "int8" },
        { name = "islefthand", default = 0, ["type"] = "bool" },
        { name = "hitplayerid", default = 0, ["type"] = "uint64" },
        { name = "damage", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerFireResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["weapontype"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int8", 8, 8, 0)
        end

        value = data["islefthand"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 72, 0)
        end

        value = data["hitplayerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 2, 0)
        end

        value = data["damage"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 3, 0)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerFireResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerFireResult, 0)

        -- skip header & struct pointer
        _M.MsgPlayerFireResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["weapontype"] = read_struct_field(p32, "int8", 8, 8, 0)

        s["islefthand"] = read_struct_field(p32, "bool", 1, 72, 0)

        s["hitplayerid"] = read_struct_field(p32, "uint64", 64, 2, 0)

        s["damage"] = read_struct_field(p32, "float32", 32, 3, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerFireResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerReloadResult = {
    id = "12384671793267145814",
    displayName = "msg_capn.capnp:MsgPlayerReloadResult",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "islefthand", default = 0, ["type"] = "bool" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerReloadResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["islefthand"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "bool", 1, 64, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerReloadResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerReloadResult, 0)

        -- skip header & struct pointer
        _M.MsgPlayerReloadResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["islefthand"] = read_struct_field(p32, "bool", 1, 64, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerReloadResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerChangeWeaponResult = {
    id = "15561498496400664448",
    displayName = "msg_capn.capnp:MsgPlayerChangeWeaponResult",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "weaponid", default = 0, ["type"] = "uint16" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerChangeWeaponResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["weaponid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint16", 16, 4, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerChangeWeaponResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerChangeWeaponResult, 0)

        -- skip header & struct pointer
        _M.MsgPlayerChangeWeaponResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["weaponid"] = read_struct_field(p32, "uint16", 16, 4, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerChangeWeaponResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerMoveStopResult = {
    id = "10063346591744624838",
    displayName = "msg_capn.capnp:MsgPlayerMoveStopResult",
    dataWordCount = 3,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 4,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "posx", default = 0, ["type"] = "float32" },
        { name = "posy", default = 0, ["type"] = "float32" },
        { name = "posz", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerMoveStopResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["posx"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 2, 0)
        end

        value = data["posy"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 3, 0)
        end

        value = data["posz"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 4, 0)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerMoveStopResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerMoveStopResult, 0)

        -- skip header & struct pointer
        _M.MsgPlayerMoveStopResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["posx"] = read_struct_field(p32, "float32", 32, 2, 0)

        s["posy"] = read_struct_field(p32, "float32", 32, 3, 0)

        s["posz"] = read_struct_field(p32, "float32", 32, 4, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerMoveStopResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerMoveStartResult = {
    id = "14595175168691373998",
    displayName = "msg_capn.capnp:MsgPlayerMoveStartResult",
    dataWordCount = 3,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 5,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "dir", default = 0, ["type"] = "float32" },
        { name = "posx", default = 0, ["type"] = "float32" },
        { name = "posy", default = 0, ["type"] = "float32" },
        { name = "posz", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerMoveStartResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["dir"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 2, 0)
        end

        value = data["posx"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 3, 0)
        end

        value = data["posy"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 4, 0)
        end

        value = data["posz"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 5, 0)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerMoveStartResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerMoveStartResult, 0)

        -- skip header & struct pointer
        _M.MsgPlayerMoveStartResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["dir"] = read_struct_field(p32, "float32", 32, 2, 0)

        s["posx"] = read_struct_field(p32, "float32", 32, 3, 0)

        s["posy"] = read_struct_field(p32, "float32", 32, 4, 0)

        s["posz"] = read_struct_field(p32, "float32", 32, 5, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerMoveStartResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerMoveMeetObstacleResult = {
    id = "14925687318323503958",
    displayName = "msg_capn.capnp:MsgPlayerMoveMeetObstacleResult",
    dataWordCount = 3,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 4,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "posx", default = 0, ["type"] = "float32" },
        { name = "posy", default = 0, ["type"] = "float32" },
        { name = "posz", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerMoveMeetObstacleResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["posx"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 2, 0)
        end

        value = data["posy"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 3, 0)
        end

        value = data["posz"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 4, 0)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerMoveMeetObstacleResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerMoveMeetObstacleResult, 0)

        -- skip header & struct pointer
        _M.MsgPlayerMoveMeetObstacleResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["posx"] = read_struct_field(p32, "float32", 32, 2, 0)

        s["posy"] = read_struct_field(p32, "float32", 32, 3, 0)

        s["posz"] = read_struct_field(p32, "float32", 32, 4, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerMoveMeetObstacleResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerFaceResult = {
    id = "13270871806930549123",
    displayName = "msg_capn.capnp:MsgPlayerFaceResult",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "yaw", default = 0, ["type"] = "float32" },
        { name = "pitch", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerFaceResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["yaw"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 2, 0)
        end

        value = data["pitch"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 3, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerFaceResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerFaceResult, 0)

        -- skip header & struct pointer
        _M.MsgPlayerFaceResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["yaw"] = read_struct_field(p32, "float32", 32, 2, 0)

        s["pitch"] = read_struct_field(p32, "float32", 32, 3, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerFaceResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerReviveResult = {
    id = "13938696202751315666",
    displayName = "msg_capn.capnp:MsgPlayerReviveResult",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "playerid", default = 0, ["type"] = "uint64" },
        { name = "health", default = 0, ["type"] = "uint64" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerReviveResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["playerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["health"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 1, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerReviveResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerReviveResult, 0)

        -- skip header & struct pointer
        _M.MsgPlayerReviveResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["playerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["health"] = read_struct_field(p32, "uint64", 64, 1, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerReviveResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPlayerProjectileDamageResult = {
    id = "14444602594084582812",
    displayName = "msg_capn.capnp:MsgPlayerProjectileDamageResult",
    dataWordCount = 1,
    pointerCount = 1,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "weapontype", default = 0, ["type"] = "int8" },
        { name = "damageplayers", default = "opaque pointer", ["type"] = "list" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        -- list
        if data["damageplayers"] and type(data["damageplayers"]) == "table" then
            size = size + 8
            local num2 = #data["damageplayers"]
            for i2=1, num2 do
                size = size + _M.MsgDamagePlayer.calc_size_struct(data["damageplayers"][i2])
            end
        end
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPlayerProjectileDamageResult.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["weapontype"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int8", 8, 0, 0)
        end

        value = data["damageplayers"]
        if type(value) == "table" then
            local data_off = get_data_off(_M.MsgPlayerProjectileDamageResult, 0, pos)
            pos = pos + write_list(p32 + _M.MsgPlayerProjectileDamageResult.dataWordCount * 2 + 0 * 2,
                    value, (data_off + 1) * 8, "list", "struct", _M.MsgDamagePlayer)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPlayerProjectileDamageResult.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPlayerProjectileDamageResult, 0)

        -- skip header & struct pointer
        _M.MsgPlayerProjectileDamageResult.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["weapontype"] = read_struct_field(p32, "int8", 8, 0, 0)

        -- list
        local off, size, num = read_listp_struct(p32, header, _M.MsgPlayerProjectileDamageResult, 0)
        if off and num then
            -- dataWordCount + offset + pointerSize + off
            s["damageplayers"] = read_list_data(p32 + (1 + 0 + 1 + off) * 2, header,
                    num, "struct", _M.MsgDamagePlayer)
        else
            s["damageplayers"] = nil
        end

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPlayerProjectileDamageResult.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPvpGameStartCoundown = {
    id = "16394127836725534489",
    displayName = "msg_capn.capnp:MsgPvpGameStartCoundown",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "time", default = 0, ["type"] = "float64" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPvpGameStartCoundown.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["time"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float64", 64, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPvpGameStartCoundown.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPvpGameStartCoundown, 0)

        -- skip header & struct pointer
        _M.MsgPvpGameStartCoundown.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["time"] = read_struct_field(p32, "float64", 64, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPvpGameStartCoundown.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPvpGameStart = {
    id = "17234466466247840424",
    displayName = "msg_capn.capnp:MsgPvpGameStart",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "time", default = 0, ["type"] = "float64" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPvpGameStart.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["time"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float64", 64, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPvpGameStart.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPvpGameStart, 0)

        -- skip header & struct pointer
        _M.MsgPvpGameStart.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["time"] = read_struct_field(p32, "float64", 64, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPvpGameStart.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPvpGameTickTimeMeet = {
    id = "9419185109797634095",
    displayName = "msg_capn.capnp:MsgPvpGameTickTimeMeet",
    dataWordCount = 1,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 1,

    fields = {
        { name = "time", default = 0, ["type"] = "float64" },
    },

    calc_size_struct = function(data)
        local size = 8
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPvpGameTickTimeMeet.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 8 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["time"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float64", 64, 0, 0)
        end
        return pos - start + 8
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPvpGameTickTimeMeet.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPvpGameTickTimeMeet, 0)

        -- skip header & struct pointer
        _M.MsgPvpGameTickTimeMeet.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["time"] = read_struct_field(p32, "float64", 64, 0, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPvpGameTickTimeMeet.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPvpNotifySpawnMonster = {
    id = "15014033947214375328",
    displayName = "msg_capn.capnp:MsgPvpNotifySpawnMonster",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "serverid", default = 0, ["type"] = "uint64" },
        { name = "monsterid", default = 0, ["type"] = "int8" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPvpNotifySpawnMonster.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["serverid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["monsterid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "int8", 8, 8, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPvpNotifySpawnMonster.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPvpNotifySpawnMonster, 0)

        -- skip header & struct pointer
        _M.MsgPvpNotifySpawnMonster.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["serverid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["monsterid"] = read_struct_field(p32, "int8", 8, 8, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPvpNotifySpawnMonster.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgPosition = {
    id = "14195538486029697216",
    displayName = "msg_structs.capnp:MsgPosition",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "posx", default = 0, ["type"] = "float32" },
        { name = "posy", default = 0, ["type"] = "float32" },
        { name = "posz", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgPosition.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["posx"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 0, 0)
        end

        value = data["posy"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 1, 0)
        end

        value = data["posz"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 2, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgPosition.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgPosition, 0)

        -- skip header & struct pointer
        _M.MsgPosition.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["posx"] = read_struct_field(p32, "float32", 32, 0, 0)

        s["posy"] = read_struct_field(p32, "float32", 32, 1, 0)

        s["posz"] = read_struct_field(p32, "float32", 32, 2, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgPosition.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgRotation = {
    id = "11645199107044771795",
    displayName = "msg_structs.capnp:MsgRotation",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "rotaionx", default = 0, ["type"] = "float32" },
        { name = "rotaiony", default = 0, ["type"] = "float32" },
        { name = "rotaionz", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgRotation.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["rotaionx"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 0, 0)
        end

        value = data["rotaiony"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 1, 0)
        end

        value = data["rotaionz"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 2, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgRotation.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgRotation, 0)

        -- skip header & struct pointer
        _M.MsgRotation.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["rotaionx"] = read_struct_field(p32, "float32", 32, 0, 0)

        s["rotaiony"] = read_struct_field(p32, "float32", 32, 1, 0)

        s["rotaionz"] = read_struct_field(p32, "float32", 32, 2, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgRotation.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgNetdelay = {
    id = "9933007626901436720",
    displayName = "msg_structs.capnp:MsgNetdelay",
    dataWordCount = 2,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 2,

    fields = {
        { name = "time", default = 0, ["type"] = "float64" },
        { name = "delay", default = 0, ["type"] = "uint32" },
    },

    calc_size_struct = function(data)
        local size = 16
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgNetdelay.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 16 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["time"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float64", 64, 0, 0)
        end

        value = data["delay"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "uint32", 32, 2, 0)
        end
        return pos - start + 16
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgNetdelay.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgNetdelay, 0)

        -- skip header & struct pointer
        _M.MsgNetdelay.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["time"] = read_struct_field(p32, "float64", 64, 0, 0)

        s["delay"] = read_struct_field(p32, "uint32", 32, 2, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgNetdelay.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

_M.MsgDamagePlayer = {
    id = "17467738649109121594",
    displayName = "msg_structs.capnp:MsgDamagePlayer",
    dataWordCount = 3,
    pointerCount = 0,
    discriminantCount = 0,
    discriminantOffset = 0,
    field_count = 3,

    fields = {
        { name = "causerid", default = 0, ["type"] = "uint64" },
        { name = "hitplayerid", default = 0, ["type"] = "uint64" },
        { name = "damage", default = 0, ["type"] = "float32" },
    },

    calc_size_struct = function(data)
        local size = 24
        local value
        return size
    end,

    calc_size = function(data)
        local size = 16 -- header + root struct pointer
        return size + _M.MsgDamagePlayer.calc_size_struct(data)
    end,

    flat_serialize = function(data, p32, pos)
        pos = pos and pos or 24 -- struct size in bytes
        local start = pos
        local dscrm
        local value

        value = data["causerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 0, 0)
        end

        value = data["hitplayerid"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" or data_type == "cdata") then

            write_struct_field(p32, value, "uint64", 64, 1, 0)
        end

        value = data["damage"]
        local data_type = type(value)
        if (data_type == "number"
                or data_type == "boolean" ) then

            write_struct_field(p32, value, "float32", 32, 4, 0)
        end
        return pos - start + 24
    end,

    serialize = function(data, p8, size)
        if not p8 then
            size = _M.MsgDamagePlayer.calc_size(data)

            p8 = get_str_buf(size)
        end
        ffi_fill(p8, size)
        local p32 = ffi_cast(puint32, p8)

        -- Because needed size has been calculated, only 1 segment is needed
        p32[0] = 0
        p32[1] = (size - 8) / 8

        -- skip header
        write_structp(p32 + 2, _M.MsgDamagePlayer, 0)

        -- skip header & struct pointer
        _M.MsgDamagePlayer.flat_serialize(data, p32 + 4)

        return ffi_string(p8, size)
    end,

    parse_struct_data = function(p32, data_word_count, pointer_count, header,
            tab)

        local s = tab

        s["causerid"] = read_struct_field(p32, "uint64", 64, 0, 0)

        s["hitplayerid"] = read_struct_field(p32, "uint64", 64, 1, 0)

        s["damage"] = read_struct_field(p32, "float32", 32, 4, 0)

        return s
    end,

    parse = function(bin, tab)
        if #bin < 16 then
            return nil, "message too short"
        end

        local header = new_tab(0, 4)
        local p32 = ffi_cast(puint32, bin)
        header.base = p32

        local nsegs = p32[0] + 1
        header.seg_sizes = {}
        for i=1, nsegs do
            header.seg_sizes[i] = p32[i]
        end
        local pos = round8(4 + nsegs * 4)
        header.header_size = pos / 8
        p32 = p32 + pos / 4

        if not tab then
            tab = new_tab(0, 8)
        end
        local off, dw, pw = read_struct_buf(p32, header)
        if off and dw and pw then
            return _M.MsgDamagePlayer.parse_struct_data(p32 + 2 + off * 2, dw, pw,
                    header, tab)
        else
            return nil
        end
    end,

}

return _M
